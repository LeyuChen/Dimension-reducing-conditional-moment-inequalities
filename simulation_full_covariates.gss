
/*   This program was used to produce the Monte Carlo simulation results reported 
     in Chen and Lee (2018) "Breaking the curse of dimensionality in conditional 
     moment inequalities for discrete choice models" Journal of Econometrics, forthcoming.
     
     The program simulates the following binary choice model:
     
     Y = 1{ X*beta >= e }, where
     
     beta is a d-dimensional parameter vector with beta[1] = 1 and beta[2:d] = 0,
     X is a d-dimensional covariate vector with X[2:d] being a vector of independent Uniform(-1,1) random variables and 
     e=sqrt(1+X[1]^2+X[2]^2+...+X[d]^2)*eta with eta|x ~ N(0,1).
     X[1], the first component of X, is generated by X[1] = sign(X[2])*U where U|X[2:d],eta ~ Uniform(0,1).
     
     In the simulation, given a candidate parameter vector b, the program implements the CLR test for testing whether 
     the vector b satisfies the identifying conditional moment inequalities of this model. The CLR test implementation 
     is based on moment inequalities conditional on all covariates. This CLR test formulation is computationally simpler
     yet it suffers more from the curse of dimensionality and thus has lower test power. 
*/

new;

rndseed 9999;


// initialize simulation configurations

alpha = 0.05; // significance level

d=3; // dimension of the covariate vector

beta = zeros(d,1); beta[1]=1;             

N = 250; // change here for alternative sample size

R = 1000; // simulation repetitions

B_size = 4000; // simulation draws for calculating the CLR test critical value

rndgrid=1000; // the number of randomly drawn grid points 

tuning = 0.1/log(N); // tuning parameter for improving the CLR test power

u=rndn(N,B_size); // random multipliers used in the CLR test implementation

test_b=zeros(B_size,1); // simulated version of the test statistic

b_c=2.65; // bandwidth scale 

b=zeros(d,1); b[1]=beta[1]; // b is a candidate value of preference parameter

b[2]=-1; 

test_power_CLR=0;

x=zeros(rndgrid,d); // random grid for the space of v=(x(1),x(2),x(3),..., x(d))

v_hat_CLR = zeros(rndgrid,1); // v_hat stores the indices of v in the estimated contact set

wsize_CLR = b_c/(N^(11/70));      // undersmoothing for d=3;
//wsize_CLR=b_c/(N^(1/9)); // undersmoothing for d=4;

//wsize_CLR=b_c/(N^(21/220)); // undersmoothing for d=5

//wsize_CLR=b_c/(N^(1/21)); // undersmoothing for d=10

hsize_CLR=ones(d,1);

kern_values_CLR = zeros(N,rndgrid); // store the kernel function values evaluated at grid points
u_hat_CLR = zeros(N,1);
w_hat_CLR=zeros(N,rndgrid);

sigma_hat_CLR=zeros(rndgrid,1);
std_m_hat_CLR = zeros(rndgrid,1);

xb=zeros(N,1);

temp1=zeros(N,1);
temp2=zeros(N,1);
temp3=zeros(N,rndgrid);

temp_k=zeros(N,N);

datax=zeros(N,d);
y=zeros(N,1);
e=zeros(N,1);

print "iteration started at : " timestr(time);

// the main simulation repetitions start from here

for i (1, R, 1); 

/* DGP setup :

(X_2, ..., X_d) : i.i.d. U(-1,1)
X_1 = U(0,1)*sign(X_2)

*/

// generate the random grid search directions
x[.,2:d]=2*rndu(rndgrid,d-1)-1;
x[.,1]=rndu(rndgrid,1).*((x[.,2] .>=0)-(x[.,2] .<0));

v_hat_CLR = zeros(rndgrid,1); 

// generate the covariate data
datax[.,2:d]=2*rndu(N,d-1)-1;
datax[.,1]=rndu(N,1).*((datax[.,2] .>=0)-(datax[.,2] .<0));

e=sqrt(1+(sumr(datax^2))).*rndn(N,1); // generate the model unobservables

y=(datax*beta).>=e; // generate the choice data

xb=datax*b;

temp1=xb^2;
temp2=xb.*(y-0.5);

hsize_CLR=wsize_CLR*stdc(datax);

kern_values_CLR = ones(N,rndgrid); 

temp_k=ones(N,N);

 for k2 (1, d, 1);

 kern_values_CLR=kern_values_CLR.*kern((x[.,k2]'-datax[.,k2])/hsize_CLR[k2]);

 temp_k=temp_k.*kern((datax[.,k2]'-datax[.,k2])/hsize_CLR[k2]);

 endfor;

u_hat_CLR=y-sumc(y.*temp_k)./(1e-8 +sumc(temp_k));

temp3=u_hat_CLR.*kern_values_CLR;

sigma_hat_CLR=sqrt(sumc(temp1.*temp3.*temp3));
std_m_hat_CLR=sumc(temp2.*kern_values_CLR)./sigma_hat_CLR;
w_hat_CLR=xb.*temp3./(sigma_hat_CLR');

test_CLR=minc(std_m_hat_CLR);  // the CLR test statistic

test_b_CLR=minc((w_hat_CLR')*u);

q_hat_CLR=quantile(test_b_CLR,tuning);

v_hat_CLR=(std_m_hat_CLR .<=(-2*q_hat_CLR));   // construction of the estimated contact set

test_b_CLR=minc(selif((w_hat_CLR'),v_hat_CLR)*u);

q_hat_CLR=quantile(test_b_CLR,alpha);  // the refined CLR test critical value using the estimated contact set

if test_CLR<q_hat_CLR;
test_power_CLR=test_power_CLR+1;
endif;

endfor; // end of main simulation repetition

print "iteration finished at : " timestr(time);

print "sample size :" N;
print "bandwidth scale :" b_c;
print "candidate parameter value" b;
print "simulated test rejection probability" test_power_CLR/R; 


proc(1) = kern(v);
retp(((15/16)*((1-v^2)^2)).*(abs(v) .<= 1));     // biweight kernel
//retp((105/64)*(1-3*v^2).*((1-v^2)^2).*(abs(v) .<= 1)); // biweight fourth order kernel
//retp ((4725/2048)*(1-(22/3)*v^2+(143/15)*v^4).*((1-v^2)^2).*(abs(v) .<= 1)); // biweight sixth order kernel
endp;


