
/*   This program was used to produce the Monte Carlo simulation results reported 
     in Chen and Lee (2018) "Breaking the curse of dimensionality in conditional 
     moment inequalities for discrete choice models" Journal of Econometrics, forthcoming.
     
     The program simulates the following binary choice model:
     
     Y = 1{ X*beta >= e }, where
     
     beta is a d-dimensional parameter vector with beta[1] = 1 and beta[2:d] = 0,
     X is a d-dimensional covariate vector with X[2:d] being a vector of independent Uniform(-1,1) random variables and 
     e=sqrt(1+X[1]^2+X[2]^2+...+X[d]^2)*eta with eta|x ~ N(0,1).
     X[1], the first component of X, is generated by X[1] = sign(X[2])*U where U|X[2:d],eta ~ Uniform(0,1).
     
     In the simulation, given a candidate parameter vector b, the program implements the CLR test for testing whether 
     the vector b satisfies the identifying conditional moment inequalities of this model. The CLR test implementation 
     is based on the index formulated conditional moment inequalities and its algorithm is described in Section 4 of the paper. 
     This implementation enjoys the effect of dimension reduction through moment inequalities conditional on indexing variables. 
     Compared to the test based on moment inequalities conditional on all covariates, this formulation yields higher test power 
     but may incur higher computational cost.
     
*/

new;

rndseed 9999;

// initialize simulation configurations

alpha = 0.05; // significance level

d=3; // dimension of the covariate vector

beta = zeros(d,1); beta[1]=1;             

N = 250; // change here for alternative sample size

R = 1000; // simulation repetitions 

B_size = 4000; // simulation draws for calculating the CLR test critical value

rndgrid=1000; // the number of randomly drawn grid points 

tuning = 0.1/log(N); // tuning parameter for improving the CLR test power

u=rndn(N,B_size); // random multipliers used in the CLR test implementation

test_b=zeros(B_size,1); // simulated version of the test statistic

b_c=3.05; // bandwidth scale 

wsize = b_c/(N^(1/5)); // undersmoothing bandwidth setup for the 2nd order kernel based bivariate kernel regression estimator
hsize_gamma=ones(rndgrid,1);

// b1 is normalized to be 1 

b=zeros(d,1); b[1]=beta[1]; // b is a candidate value of preference parameter

b[2]=0.5;

test_power=0;

// random grid for the space of v=(x(1),x(2),x(3),..., x(d),gamma(2), gamma(3), ...., gamma(d))

x=zeros(rndgrid,d);
gamma_p=zeros(d,rndgrid);
gamma_p[1,.]=beta[1]*ones(1,rndgrid);

// v_hat stores the indices of v in the estimated contact set

v_hat = zeros(rndgrid,1); 

kern_values = zeros(N,rndgrid); // store the kernel function values evaluated at grid points
e_hat = zeros(N,rndgrid); // store E_hat(Y|X[i]'b,X[i]'r[k1])
u_hat=zeros(N,rndgrid);
w_hat=zeros(N,rndgrid);

sigma_hat=zeros(rndgrid,1);
std_m_hat = zeros(rndgrid,1);

xb=zeros(N,1);
xr=zeros(N,rndgrid);
kern_xb=zeros(N,N);

temp1=zeros(N,1);
temp2=zeros(N,1);
temp3=zeros(N,rndgrid);

temp_k=zeros(N,N);

datax=zeros(N,d);
y=zeros(N,1);
e=zeros(N,1);

print "iteration started at : " timestr(time);

// the main simulation repetitions start from here

for i (1, R, 1); 

/* DGP setup :

(X_2, ..., X_d) : i.i.d. U(-1,1)
X_1 = U(0,1)*sign(X_2)

*/


// generate the random grid search directions
x[.,2:d]=2*rndu(rndgrid,d-1)-1;
x[.,1]=rndu(rndgrid,1).*((x[.,2] .>=0)-(x[.,2] .<0));
gamma_p[2:d,.]=2*rndu(d-1,rndgrid)-1;

v_hat = zeros(rndgrid,1); // reset the contact set

// generate the covariate data
datax[.,2:d]=2*rndu(N,d-1)-1;
datax[.,1]=rndu(N,1).*((datax[.,2] .>=0)-(datax[.,2] .<0));

e=sqrt(1+(sumr(datax^2))).*rndn(N,1); // generate the model unobservables

y=(datax*beta).>=e; // generate the choice data

xb=datax*b;
xr=datax*gamma_p;

temp1=xb^2;
temp2=xb.*(y-0.5);

hsize_xb=wsize*stdc(xb);
hsize_gamma=wsize*stdc(xr);

kern_values=kern((((x*b)')-xb)/hsize_xb).*kern((((diag(x*gamma_p))')-xr)./(hsize_gamma'));

kern_xb=kern(((xb')-xb)/hsize_xb);

for k1 (1,rndgrid,1);

temp_k=kern_xb.*kern(((xr[.,k1]')-xr[.,k1])/hsize_gamma[k1]);
e_hat[.,k1]=sumc(y.*temp_k)./(1e-8 +sumc(temp_k));

endfor;

u_hat=y-e_hat; // construct the nonparametric residual : u_hat[i][k1]= Y[i] - E_hat(Y|X[i]'b,X[i]'r[k1])

temp3=u_hat.*kern_values;

sigma_hat=sqrt(sumc(temp1.*temp3.*temp3));
std_m_hat=sumc(temp2.*kern_values)./sigma_hat;
w_hat=xb.*temp3./(sigma_hat');

test=minc(std_m_hat);  // the CLR test statistic

test_b=minc((w_hat')*u);

q_hat=quantile(test_b,tuning);

v_hat=(std_m_hat.<=(-2*q_hat));  // construction of the estimated contact set

test_b=minc((selif((w_hat'),v_hat))*u);

q_hat=quantile(test_b,alpha); // the refined CLR test critical value using the estimated contact set

if test<q_hat;
test_power=test_power+1;
endif;

endfor; // end of main simulation repetition

print "iteration finished at : " timestr(time);

print "sample size :" N;
print "bandwidth scale :" b_c;
print "candidate parameter value" b;
print "simulated test rejection probability" test_power/R;


/**********************************************************/
/*************** 2nd Order Kernel Function ****************/
/**********************************************************/
proc(1) = kern(v);
retp(((15/16)*((1-v^2)^2)).*(abs(v) .<= 1));     // biweight kernel
endp;


